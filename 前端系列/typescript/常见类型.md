# TypeScript 常见类型

## 特殊类型

### 1. any

当值指定为 `any` 类型时表示该值不会被类型系统检查，也可以说这个值可以是任何类型，没有任何限制。

TS 将 any 类型称为“顶层类型”（top level），即是其他所有类型的全集

any 类型的变量可以赋予任何类型的值，也可以被赋予任何类型的变量：

```ts
let x: any;
x = 1; // 正确
x = true; // 正确

let y: string;
y = x; // 正确
```

实际开发中应该尽量避免使用 any 类型，否则就是去了使用 TS 的意义。

默认配置下未指定类型且无法被推断的值就会被识别为 any 类型：

```ts
function add(x, y) {
  // x和y都是any类型
  return x + y;
}
// 不会包错
add(true, [1, 2, 3]);
```

如果开启了 TS 提供了的 `noImplicitAny` 编译选项，那么未指定类型且无法识别的值就会报错：

```ts
// Parameter 'x' implicitly has an 'any' type.
// Parameter 'y' implicitly has an 'any' type.
function add(x, y) {
  return x + y;
}
```

但是有个例外是使用 `var` 或 `let` 声明变量但不指定值是不会报错的：

```ts
var x; // 不报错
let y; // 不报错
```

所以在使用 `let` 和 `var` 时建议显式声明类型。

any 类型处理不检查类型之外，还有个问题是会“污染”其他变量，因为 any 可以赋值给其他任何类型的变量，这可能导致其他变量出错。

```ts
let x: any = "hello";
let y: number;

y = x; // 不报错

y * 123; // 不报错
y.toFixed(); // 不报错
```

上面的示例中因为 x 是 any 类型，所以代码不会有类型报错，但是实际运行时却会出现错误，这也是不宜使用 any 类型的另一个主要原因。

2. unknown

TS 在 3.0 版本引入了 `unknown` 类型，表示“不确定”类型。它与 any 类似可以是任意类型，但是无法像 any 一样被自由分配和调用。

```ts
let x: unknown;
// unknown 和 any 一样可以赋值为任意类型
x = true; // 不报错
x = 42; // 不报错
// 但是不能直接使用
let y: boolean = x; // 报错
x.toString(); // 报错
```

unknown 能够进行的运算是有限的，只能进行比较运算（运算符`==`、`===`、`!=`、`!==`、`||`、`&&`、`?`）、取反运算（运算符`!`）、`typeof`运算符和`instanceof`运算符这几种，其他运算都会报错。

```ts
let a: unknown = 1;

a + 1; // 报错
a === 1; // 正确
```

正确使用 unknown 类型的方法是经过“类型收窄”，也就是将不确定的类型确定为具体的类型，来保证代码不会出错，例如：

```ts
let a: unknown = 1;

if (typeof a === "number") {
  a++; // 正确
}
```

上面的代码通过 typeof 运算确定 a 是数字类型，可以保证后续代码不会出错。

unknown 提供了一个不确定的类型，这样设计的目的是填补 any 类型可以随意使用的问题。在集合论上，unknown 也可以视为所有其他类型（除了 any）的全集，所以它和 any 一样，也属于 TypeScript 的顶层类型。
