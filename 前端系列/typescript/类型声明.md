# TypeScript 类型声明

## 全局声明

前面提到了有导入、导出语句存在的文件被 TS 视为一个模块，模块内的类型有自己的作用域，其他文件只能导入后使用。而没有导入、导出语句的文件则被 TS 视为全局脚本文件，全局脚本文件被 TS 编译后，其中的类型便可以在 TS 编译范围内的其他文件中直接使用。

我们可以创建一个示例项目查看：

```sh
# 创建 ts-test 项目文件夹
mkdir ts-test
# 进入文件夹
cd ts-test
# 创建 package.json
npm init -y
# 创建 tsconfig.json（需要全局安装 typescript 库）
tsc --init
```

创建 `ts-test` 项目后，使用编辑器打开，分别创建 `a.ts` 和 `b.ts` 文件作为示例。在 a 文件中写入一些类型：

```ts
// a.ts
type A = number;

interface B {
  b: string;
}

class C {
  c = true;
}
```

然后在 b 文件中使用这些类型：

```ts
// b.ts
let a: A = 1;

let b: B = { b: "b" };

let c: C = { c: true };
```

可以看到 b 文件中虽然没有引入 A、B、C 类型，但是依然没有报错。这是因为 tsconfig.json 中`include`编译选项的默认值包含了所有文件，所以 a 文件会被 ts 编译。而 a 文件没有导入导出语句，会被 ts 识别为一个全局声明文件，所以内部的类型可以直接在其他编译范围内的文件中使用。

前文提到了同名 interface、class 会进行类型合并，所以在全局声明文件中，也可以利用这个特性来拓展类型。例如可以往全局的`Window`类型中添加定义：

```ts
// a.ts
interface Window {
  d: "d";
}
```

```ts
// b.ts
let d = window.d; // 不报错，此时变量 d 的类型为 “d”
```

全局声明文件的作用就是用来定义全局可用的类型，此时如果将 a 文件中的类型定义都注释掉就可以看到 b 文件中全部类型使用都报错了。

::: tip 内置声明文件
安装 TS 时，会同时安装一些内置类型声明文件，主要是内置的全局对象（JS 和浏览器 API 等）类型声明。

紫萼内置声明文件位于 TS 安装目录的 `lib` 文件夹中，大概有几十个，例如：

- lib.d.ts
- lib.dom.ts
- lib.es5.d.ts
- lib.es2017.d.ts

编译器会自动根据编译目标 `target` 的值，加载对应的内置声明文件，所以不需要特别的配置。但是，可以使用编译选项 `lib`，指定加载哪些内置声明文件：

```ts
{
  "compilerOptions": {
    "lib": ["dom", "es2021"]
  }
}
```

还有一个编译选项 `noLib` 会禁止加载任何内置声明文件。
:::

## declare 关键字

`declare` 关键字用来告诉编译器，某个值是存在的，可以根据 declare 给出的类型在当前文件中使用。

declare 关键字的重要特点是，它只是通知编译器某个类型是存在的，不用给出具体实现。比如，只描述函数的类型，不给出函数的实现，如果不使用 declare，这是做不到的。

declare 关键字可以描述以下类型：

### 1. declare variable

例如你知道某个脚本定义了全局变量 x，但是 TS 不知道，所以直接在当前文件中使用会报错：

```ts
x = 123; // 报错
```

此时可以用 declare 命令给出它的类型，就不会报错了。如果 declare 没有给出变量的具体类型，那么会被当作 any 类型：

```ts
declare let x: number;
// declare let x; // 此时 x 为 any 类型

x = 123; // 正确
```

注意，declare 关键字只用来给出类型描述，是纯的类型代码，不允许设置变量的初始值。

### 2. declare function

declare 关键字可以给出外部函数的类型描述：

```ts
declare function sayHello(name: string): void;

sayHello("张三");
```

### 3. declare class

declare 给出 class 类型描述的写法如下：

```ts
declare class Animal {
  constructor(name: string);
  eat(): void;
  sleep(): void;
}
```

### 4. declare module、declare namespace

如果想将变量、函数、类组织在一起，可以用 `declare module` 或 `declare namespace`。二者代码块中可以添加 `export` 关键字，也可以不加：

```ts
declare namespace myLib {
  // export 也可以不加
  export function makeGreeting(s: string): string;
  export let numberOfGreetings: number;
}
// 或者
// declare module myLib {
//   function makeGreeting(s: string): string;
//   let numberOfGreetings: number;
// }

let result = myLib.makeGreeting("你好");
let count = myLib.numberOfGreetings;
```

declare 关键字的另一个用途，是为外部模块添加属性和方法时，给出新增部分的类型描述：

```ts
import { Foo as Bar } from "./a";

declare module "./a" {
  interface Foo {
    custom: string;
  }
}
```

上面示例中，从模块 `moduleA` 导入了类型` Foo`，它是一个接口（interface），并将其重命名为 `Bar`，然后用 `declare` 关键字为 `Foo` 增加一个属性 `custom`。这里需要注意的是，虽然接口 `Foo` 改名为 `Bar`，但是扩充类型时，还是扩充原始的接口 `Foo`，因为同名 interface 会自动合并类型声明。

::: warning
使用这种语法进行模块的类型扩展时，有两点需要注意：

1. `declare module NAME` 语法里面的模块名 `NAME`，跟 import 和 export 的模块名规则是一样的，且必须跟当前文件加载该模块的语句写法（上例 `import { A } from './a'`）保持一致。
2. 不能创建新的顶层类型。也就是说，只能对` a.ts` 模块中已经存在的类型进行扩展，不允许增加新的顶层类型，比如新定义一个接口。
3. 不能对默认的 default 接口进行扩展，只能对 export 命令输出的命名接口进行扩充。这是因为在进行类型扩展时，需要依赖输出的接口名。

:::

某些第三方模块，原始作者没有提供接口类型，这时可以在自己的脚本顶部加上下面一行命令：`declare module "模块名";`。此时该模块内部的接口都将视为 `any` 类型。

`declare module` 描述的模块名还可以使用通配符：

```ts
declare module "my-plugin-*" {
  interface PluginOptions {
    enabled: boolean;
    priority: number;
  }

  function initialize(options: PluginOptions): void;
  export = initialize;
}
```

这里的 `export = initialize` 是描述模块内的默认导出，表示默认导入这个模块时得到的就是 `initialize` 的值，这是 CommonJS 中的默认导出语法，对应的还可以使用 `export default initialize;`。

### 5. declare global

如果要为 JS 原生对象添加属性和方法，可以使用 `declare global` 语法：

```ts
export {};

declare global {
  // 扩展浏览器全局对象
  interface Window {
    myAppConfig: object;
  }
}

const config = window.myAppConfig;
```

示例第一行的空导出语句 `export {}`，作用是强制编译器将这个脚本当作模块处理。这是因为 `declare global` 必须用在模块里面。`declare global` 只能扩充现有对象的类型描述，不能增加新的顶层类型。

### 6. declare enum

```ts
declare enum E1 {
  A,
  B,
}

declare const enum E2 {
  A = 0,
  B = 1,
}
```

### 7. declare module 用于类型声明文件

## d.ts 类型声明文件

单独使用的模块，一般会提供一个单独的类型声明文件（declaration file），类型声明文件中只有类型代码，没有具体实现。所以文件名一般为 `name.d.ts` 的形式。

例如有一个 `a.ts` 文件如下：

```ts
const maxInterval = 12;

function getArrayLength(arr) {
  return arr.length;
}

module.exports = {
  getArrayLength,
  maxInterval,
};
```
