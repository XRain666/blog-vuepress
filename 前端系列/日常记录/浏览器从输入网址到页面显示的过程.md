# 浏览器从输入网址到页面显示的过程

阅读[浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/guide/part1/lesson01)后整理完成，原文出处为[极客时间-浏览器工作原理与实践](https://time.geekbang.org/column/intro/100033601)

> 推荐阅读原文，本文仅整理了主要流程，未深入细节

## 流程

1. 浏览器主进程解析地址栏中的内容，如果是地址正确拼接协议；如果是搜索内容，拼接搜索地址。
2. 将请求地址交给浏览器网络进程，构建请求行
3. 查找是否存在缓存，有则直接返回缓存
4. 通过 `DNS` 域名解析得到 `IP` 地址

   查找顺序为：

   1. 查找浏览器缓存，有缓存则返回 `IP`
   2. 查找本机缓存，有缓存则返回 `IP`
   3. 查找本机配置 `DNS` 服务器，有缓存则返回 `IP`，无则由本机配置 `DNS` 服务器向根域名服务器中查找
   4. 根域名服务器会返回顶级域名服务器（.com 等）地址
   5. 本机配置 `DNS` 服务器再向顶级域名服务器查找，会返回权威域名服务器地址
   6. 本机配置 `DNS` 服务器再向权威域名服务器地址查找，找到后返回 `IP`（由域名服务商提供，能正确找到 `IP`）

5. 如果请求地址中没有端口号，使用默认端口号 `80`（`HTTP`）或 `443`（`HTTPS`）
6. 通过三次握手建立 `TCP` 连接（同一域名最多同时存在 6 个连接，如果已满需要等待）

   - 第一次握手：客户端发送 `SYN` 报文并设置序列号为 `A`，表示能够发送
   - 第二次握手：服务端回复 `ACK` 报文并设置序列号为 `A+1`，以及 `SYN` 报文并设置序列号 B，表示能够接收和发送
   - 第三次握手：客户端回复 `ACK` 报文并设置序列号为 `B+1`，表示能够接收

7. 发送 `HTTP` 请求
8. 服务端处理并返回 `HTTP` 响应，如果响应为重定向，从步骤 2 开始请求新地址；如果响应 `Content-Type` 为二进制流类型，浏览器尝试下载，否则尝试解析展示
9. 如果请求头未包含 `Connection: Keep-Alive`，则通过四次挥手断开 `TCP` 连接

   - 第一次挥手：发起断开方发送 `FIN` 报文并设置序列号为 `A`，表示自己没有要发送的内容了
   - 第二次挥手：接收断开方发送 `ACK` 报文并设置序列号为 `A+1`，表示收到断开请求，等我检查是否还需要发送
   - 第三次挥手：接收断开方发送 `FIN` 报文并设置序列号为 `B`，表示自己没有要发送的内容了
   - 第四次挥手：发起断开方发送 `ACK` 报文并设置序列号为 `B+1`，表示确认断开。此时接收断开方收到后便断开连接，而发起断开方需要等到一段时间确认报文发送成功后再断开。

10. 浏览器主进程新开一个渲染进程（如果是从协议和根域名相同的页面中打开的，会复用同一个渲染进程）
11. 浏览器主进程向渲染进程发送“提交文档”消息，渲染进程与网络进程通信并获取响应；待渲染进程接收响应完毕后向主进程发送“确认提交”消息，主进程更新浏览器界面状态
12. （如果响应是 `HTML` 代码）渲染进程开始解析 `HTML` 代码，逐个扫描 `HTML` 标签并构建 `DOM` 树

    - 当解析到 `JS` 代码时，会暂停 `HTML` 解析，加载并执行 `JS` 代码（`script` 标签带有 `async` 属性时，会异步请求脚本，并在请求完成后立即暂停 `HTML` 解析并开始执行脚本代码；带有 `defer` 属性的标签会异步请求，并在 `HTML` 解析完成后按在代码中脚本的顺序执行）
    - 当解析到其他资源时，会异步请求资源，不会阻塞 `HTML` 解析和页面渲染（图片等元素异步请求完成后会产生新的合并 Render 树、布局计算、分层、渲染事件，并加入事件循环中）

13. 将从不同来源解析得到的 `CSS` 代码（样式表与内联样式）构建为 CSSOM 树
14. 合并 `DOM` 树和 `CSSOM` 树，得到 `Render` 树。这个只会保留可见的 `DOM` 元素，并计算 `CSS` 属性应用到元素上
15. 渲染进程进行布局计算
16. 对渲染树种的元素进行分层，形成图层树

    需要单独分层的元素包括：

    1. 具有 3D 变换属性的元素，如使用 `transform`
    2. 使用硬件加速的元素，如使用 `will-change`
    3. 使用透明度属性的元素，`opacity`
    4. 使用滤镜属性的元素，如混合模式（`mix-blend-mode`）、CSS 过滤器（`filter`）和遮罩（`mask`）
    5. 具有动画（`animation`）和过度（`transition`）效果的元素
    6. 具有固定定位（`fixed`）或黏性定位（`sticky`）的元素
    7. 被裁剪的元素，如具有滚动条或使用了 `clip-path`。
    8. `video` 或 `canvas` 等特定媒体元素

17. 遍历图层树，生成每个图层的绘制指令
18. 合成线程对页面进行栅格化（分块），并优先绘制视口附近的块，之后合并每一块的图像
19. 将图像显示到屏幕上
