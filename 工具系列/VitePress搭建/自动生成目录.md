# VitePress 自动生成 Sidebar

在[配置解析](/工具系列/VitePress搭建/配置解析#项目配置)中介绍了通过 nav 与 sidebar 属性配置文档上方与侧边栏目录。但文章数量上去后手动配置较为麻烦，可以通过 Vite 插件的方式自动读取文件并生成配置项

## 实现功能

1. 根据目录结构自动生成 nav 与 sidebar（以 srcDir 为基础，忽略 srcExclude，忽略空文件夹，支持自定义匹配）
2. 支持自定义文件或文件夹是否展示、排序权重、展示名称
3. 支持热更新

比如目录格式为：

```
- A
  - a1
    - a1-1.md
    - a1-2.md
  - a2.md
- B
  - b1
    - b1-1.md
  - b2
```

生成的配置就是：

```js
{
  nav: [
    {
      text: 'A',
      activeMatch: '/A/',
      link: '/A/a1/a1-1',
    },
    {
      text: 'B',
      activeMatch: '/B/',
      link: '/B/b1/b1-1',
    },
  ],
  sidebar: {
    '/A/': [
      {
        text: 'a1',
        items: [
          { text: 'a1-1', link: '/A/a1/a1-1' },
          { text: 'a1-2', link: '/A/a1/a1-2' },
        ],
      },
      { text: 'a2', link: '/A/a2' },
    ],
    '/B/': [
      {
        text: 'b1',
        items: [
          { text: 'b1-1', link: '/B/b1/b1-1' },
        ],
      },
    ],
  }
}
```

::: tip
可以直接使用中文作为文件、文件夹名
:::

## 使用方式

安装 vite-plugin-vitepress-auto-sidebar

```sh
# 推荐使用 pnpm
pnpm i vite-plugin-vitepress-auto-nav -D
```

添加插件到 `.vitepress/config.ts`

```ts
import AutoNav from 'vite-plugin-vitepress-auto-nav'

export default defineConfig({
  vite: {
    plugins: [
      AutoNav({
        // 可以自定义配置
      }),
    ],
  },
})
```

### 配置项

```ts
interface Options {
  /**
   * glob 匹配表达式
   * 会匹配 srcDir 目录下，除 srcExclude 配置外的，满足表达式的 md 文件
   * 默认：**/*.md
   */
  pattern?: string | string[]
  /**
   * 对特定文件或文件夹进行配置
   * 键名为文件(夹)名或路径（名称存在重复时，可以用路径区分，md 扩展名可以省略）
   * 生成的 nav 中的 link 默认为目录下第一篇文章路径，如果需要更复杂的配置可以直接在 config.ts 中定义，此时插件不会再生成并修改 nav 配置
   * hide：是否展示
   * sort：排序权重，权重越大越靠前
   * title：重新定义展示名称
   * collapsed: 同 sidebar 中的配置，默认为 false（支持折叠，默认展开）
   */
  settings?: PluginSettings
  /**
   * 自定义排序方法，同级文件(夹)会调用这个函数进行排序
   * 未定义时，会先按照 sort 权重降序排列，再按照创建时间升序排列
   * 也就是 大权重 > 小权重 > 先创建的文件 > 后创建的文件
   */
  compareFn?: (a: FileInfo, b: FileInfo) => number
}

interface FileInfo {
  name: string
  isFolder: boolean
  createTime: number
  updateTime: number
  hide?: boolean
  sort?: number
  title?: string
  collapsed?: boolean
  children: FileInfo[]
}

interface PluginSettings {
  [key: string]: Pick<FileInfo, 'hide' | 'sort' | 'title'> & { collapsed?: boolean }
}
```

### 配置示例

```ts
vite: {
  plugins: [
    AutoNav({
      pattern: ["!**/README.md"], // 也可以在这里排除不展示的文件，例如不匹配 README 文件
      settings: {
        a: { hide: true }, // a.md 不显示在目录中
        b: { title: 'bb' }, // 可以重新定义目录中的展示名
        c/c1: { sort : 9 }, // 名称相同时可以用路径精确匹配
        c2: { sort : 8 }, // 自定义排序权重，c2 会显示在 c1 后面，显示在未定义 sort 的文件前面
        d: { collapsed: 'cc' }, // 定义文件夹折叠配置
      },
      compareFn: (a, b) => {
        // 按修改时间升序排列
        return b.updateTime - a.updateTime
      }
    }),
  ],
}
```

## 实现思路

在 vite config 钩子中能够获取以及修改 vitepress 当前的配置

1. 获取 scrDir 以及 srcExclude 配置后通过 [fast-glob](https://github.com/mrmlnc/fast-glob) 库获取全部 md 文件路径：

```ts
// 支持手动传入匹配模式或匹配全部
const pattern = options.pattern || '**/*.md'

// 读取需要的md文件
const paths = (
  await glob(pattern, {
    cwd: srcDir,
    ignore: ['**/node_modules/**', '**/dist/**', 'index.md', ...srcExclude],
  })
)
```

2. 通过将 md 文件路径列表处理成结构化的数组（数组需要进行排序），便于后续操作：

```js
[
  {
    name: '',
    isFolder: true,
    createTime: 0,
    updateTime: 0,
    hide: false,
    sort: 0,
    title: '',
    collapsed: false,
    children: [
      // ...
    ]
  },
  // ...
]
```

3. 根据结构化数据生成 nav 配置。因为 nav 数据通常较短，如需更复杂的配置可以直接在 config 中配置（可以简化插件配置）

4. 根据结构化数据生成 sidebar 配置

5. 修改配置后返回新配置

6. 热更新通过在 configureServer 钩子中监听 md 文件的增删操作，触发配置文件的更新来刷新服务器实现：

```ts
configureServer({ config, watcher }: ViteDevServer) {
  const {
    vitepress: { configPath },
  } = config as ResolvedConfig & { vitepress: SiteConfig }

  // 从config中获取配置文件路径
  const $configPath = configPath?.match(/(\.vitepress.*)/)?.[1] || '.vitepress/config.ts'

  watcher.on('all', (event, path) => {
    // 开发服务器默认监听了所有文件，过滤掉 change 事件和非 md 文件操作
    if (event === 'change' || !path.endsWith('.md')) return
    fs.utimesSync($configPath, new Date(), new Date())
  })
}
```

## 完整代码

或查看[Github 仓库](https://github.com/Xaviw/vite-plugin-vitepress-auto-nav)

```ts
import { sep, normalize, join } from 'node:path'
import glob from 'fast-glob'
import fs from 'fs-extra'
import type { ResolvedConfig, ViteDevServer, Plugin, UserConfig } from 'vite'
import type { DefaultTheme, SiteConfig } from 'vitepress'

interface FileInfo {
  name: string
  isFolder: boolean
  createTime: number
  updateTime: number
  hide?: boolean
  sort?: number
  title?: string
  collapsed?: boolean
  children: FileInfo[]
}

interface PluginSettings {
  [key: string]: Pick<FileInfo, 'hide' | 'sort' | 'title'> & { collapsed?: boolean }
}

interface Options {
  pattern?: string | string[]
  settings?: PluginSettings
  compareFn?: (a: FileInfo, b: FileInfo) => number
}

export type { FileInfo, PluginSettings, Plugin }

export default function (options: Options = {}): Plugin {
  return {
    name: 'vite-plugin-vitepress-auto-nav',
    // md 文件增删时，通过触发配置文件修改操作，实现热更新功能
    configureServer({ config, watcher }: ViteDevServer) {
      const {
        vitepress: { configPath },
      } = config as ResolvedConfig & { vitepress: SiteConfig }

      // 从config中获取配置文件路径
      const $configPath = configPath?.match(/(\.vitepress.*)/)?.[1] || '.vitepress/config.ts'

      watcher.on('all', (event, path) => {
        // 开发服务器默认监听了所有文件，过滤掉 change 事件和非 md 文件操作
        if (event === 'change' || !path.endsWith('.md')) return
        fs.utimesSync($configPath, new Date(), new Date())
      })
    },
    async config(config) {
      const _config = config as UserConfig & { vitepress: SiteConfig }

      // 从vitepress配置中获取文档根路径与要排除的文档
      const {
        vitepress: {
          userConfig: { srcExclude = [], srcDir = './' },
          site: {
            themeConfig: { nav },
          },
        },
      } = _config

      // 支持手动传入匹配模式或匹配全部
      const pattern = options.pattern || '**/*.md'

      // 读取需要的md文件
      const paths = (
        await glob(pattern, {
          cwd: srcDir,
          ignore: ['**/node_modules/**', '**/dist/**', 'index.md', ...srcExclude],
        })
      )
        .map((path) => normalize(path))
        .sort()

      // 处理文件路径数组为多级结构化数据
      const data = serializationPaths(paths, options, srcDir)

      // 数据排序
      sortStructuredData(data, options.compareFn)

      // vitepress 中没有配置 nav 时自动生成
      // 因为 nav 数据项较少，可以用手动配置代替在插件中设置
      if (!nav) {
        _config.vitepress.site.themeConfig.nav = generateNav(data)
      }

      // 生成侧边栏目录
      const sidebar = generateSidebar(data)
      _config.vitepress.site.themeConfig.sidebar = sidebar

      return _config
    },
  }
}

/**
 * 处理文件路径字符串数组
 */
function serializationPaths(paths: string[], { settings = {} }: Options = {}, srcDir: string) {
  // 统一路径格式，便于匹配
  for (const key in settings) {
    settings[join(srcDir, key)] = settings[key]
  }

  const pathKeys = Object.keys(settings)

  const root: FileInfo[] = []

  for (const path of paths) {
    // 获取路径中的每一级名称
    const pathParts = join(srcDir, path).split(sep)

    let currentNode = root
    let currentPath = ''

    for (const name of pathParts) {
      currentPath = join(currentPath, name)

      // 获取时间戳
      const { birthtimeMs: createTime, ctimeMs: updateTime } = fs.statSync(currentPath)

      // 简单判断是否是文件
      const isFolder = !name.includes('.')

      // 查找是否有自定义配置
      // 先按路径匹配
      let customInfoKey = pathKeys.find((p) => currentPath === p)
      // 再按文件名匹配（仅传入文件、文件夹名时）
      if (!customInfoKey) {
        customInfoKey = pathKeys.find((p) => name === p || name.replace('.md', '') === p)
      }
      const customInfo = customInfoKey ? settings[customInfoKey] : {}

      // 跳过不展示的部分
      if (customInfo.hide) break

      let childNode = currentNode.find((node) => node.name === name)

      if (!childNode) {
        childNode = { ...customInfo, name, isFolder, createTime, updateTime, children: [] }
        currentNode.push(childNode)
      }

      currentNode = childNode.children
    }
  }
  return root
}

/**
 * 对结构化后的多级数组数据进行逐级排序
 * 优先按 sort 排序，其次时间戳排序，navSort 始终优先于时间戳
 */
function sortStructuredData(data: FileInfo[], compareFn?: (a: FileInfo, b: FileInfo) => number): FileInfo[] {
  if (typeof compareFn !== 'function') {
    compareFn = (a, b) => {
      if (a.sort !== undefined && b.sort !== undefined) {
        return b.sort - a.sort
      } else if (a.sort !== undefined) {
        return -1
      } else if (b.sort !== undefined) {
        return 1
      } else {
        return a.createTime - b.createTime
      }
    }
  }
  return data.sort(compareFn).map((item) => {
    if (item.children && item.children.length > 0) {
      item.children = sortStructuredData(item.children, compareFn)
    }
    return item
  })
}

/**
 * 生成 nav 数据
 */
function generateNav(structuredData: FileInfo[]) {
  return structuredData.map((item) => ({
    text: item.title || item.name,
    activeMatch: `/${item.name}/`,
    link: getFirstArticleFromFolder(item),
  }))
}

/**
 * 获取首层目录中第一篇文章
 */
function getFirstArticleFromFolder(data: FileInfo, path = '') {
  path += `/${data.name}`
  if (data.children.length > 0) {
    return getFirstArticleFromFolder(data.children[0], path)
  } else {
    return path
  }
}

/**
 * 生成 sidebar
 */
function generateSidebar(structuredData: FileInfo[]): DefaultTheme.Sidebar {
  const sidebar: DefaultTheme.Sidebar = {}

  for (const { name, children } of structuredData) {
    sidebar[`/${name}/`] = traverseSubFile(children, `/${name}`)
  }

  function traverseSubFile(subData: FileInfo[], parentPath: string): DefaultTheme.SidebarItem[] {
    return subData.map((file) => {
      const filePath = `${parentPath}/${file.name}`
      const fileName = file.title || file.name.replace('.md', '')
      if (file.isFolder) {
        return {
          text: fileName,
          collapsed: file.collapsed ?? false,
          items: traverseSubFile(file.children, filePath),
        }
      } else {
        return { text: fileName, link: filePath.replace('.md', '') }
      }
    })
  }

  return sidebar
}
```
