# VitePress扩展首页内容

许多的自定义主题中都有提取页面并以列表形式展示在首页的功能，例如[主题配置](/工具系列/VitePress搭建/主题配置#使用其他主题)中介绍的[vitepress-blog-zaun](https://github.com/clark-cui/vitepress-blog-zaun)

类似的实现思路都是通过`NodeJS`在构建阶段读取项目中的`md`文件，获取关键信息后存储在`.vitepress/config`配置选项`themeConfig`中，再利用存储的信息自定义首页的样式

利用这些信息，我们可以实现：

1. 在首页自定义展示文章列表
2. 实现随机跳转一篇文章按钮
3. 展示项目首次提交距今时长以及发文总数
4. 文章`frontmatter`中添加tag标签，实现tag分类的效果（本站未实现，可以自行尝试）
5. ......

## useData

官方提供了 [useData()](https://vitepress.vuejs.org/api/#usedata) `API`，可以读取页面以及项目关键信息(这也是为什么要存储在配置对象中的原因)，能够获取的信息包括：

```ts
interface VitePressData<T = any> {
  site: Ref<SiteData<T>>
  page: Ref<PageData>
  theme: Ref<T> // 定义在.vitepress/config中的themeConfig对象
  frontmatter: Ref<PageData['frontmatter']>
  title: Ref<string>
  description: Ref<string>
  lang: Ref<string>
  isDark: Ref<boolean>
  dir: Ref<string>
  localeIndex: Ref<string>
}
```

## 定义提取脚本

利用`NodeJS`提供的读取文件/文件夹`API`，可以遍历出所有`md`文件路径（或根据`sidebar`获取）；再循环读取文件的内容，解析出关键信息存储，并利用`git log`命令提供的获取提交时间功能，扩展文件创建、更新时间，就完整的得到了所需要的信息

遍历文件用到了[globby](https://github.com/sindresorhus/globby)库，内部封装了遍历逻辑，可以便捷提取需要的`md`文件

解析`md`文件用到了[gray-matter](https://github.com/jonschlinkert/gray-matter)库，这也是`VitePress`中使用的解析工具，能够提取出文件头部的`FrontMatter`信息和文章内容

获取页面提交时间参考自VitePress内获取页面最后更新时间的代码[src/node/utils/getGitTimestamp.ts](https://github.com/vuejs/vitepress/blob/main/src/node/utils/getGitTimestamp.ts)

1. 创建脚本文件`.vitepress/readPages.ts`:

::: details 脚本代码
```ts
import { globby } from 'globby'
import matter from 'gray-matter'
import { readFile } from 'fs/promises'
import { type DefaultTheme } from 'vitepress'
import { spawn } from 'child_process'

interface ReadOption {
  ignorePath?: string[]
  sidebar?: DefaultTheme.Sidebar
  path?: string
}

export interface Pages {
  frontMatter: Record<string, any>
  path: string
  content: string
  title: string
}

export default async function readPages(option: ReadOption = {}): Promise<Pages[]> {
  // 获取需要的页面路径
  let paths = await getPagePaths(option)
  let pages = await Promise.all(
    // 循环获取页面信息
    paths.map(async (item) => {
      // 获取首次提交和最后提交时间
      const date = await getGitTimestamp(item)
      // 读取并解析页面内容
      const file = await readFile(item, { encoding: 'utf-8' })
      const { data, content } = matter(file)
      data.date = date
      const path = item.replace('.md', '');
      return {
        frontMatter: data,
        path,
        content,
        title: path.split('/').pop() || path, // 从路径中获取标题
      }
    })
  )
  // 按日期降序排列
  pages.sort((a, b) => {
    return b.frontMatter.date[1] - a.frontMatter.date[1]
  })
  return pages
}

async function getPagePaths(option: ReadOption) {
  // 如果传入了sidebar，则获取sidebar中所有页面路径传入globby
  // 否则遍历所有md文件
  const patterns: string[] = option.sidebar ? getLink(option.sidebar, option.path) : ['**.md']
  return await globby(patterns, {
    ignore: ['node_modules', 'README.md', 'public', '.vitepress', 'components', 'scripts', ...(option.ignorePath || [])],
  })
}

// 使用正则提取sidebar中所有页面链接
function getLink(sidebar: DefaultTheme.Sidebar, path: string = '/docs'): string[] {
  const result: string[] = []
  const regex = /"link":"([^"]*)"/g
  let matches: RegExpExecArray | null
  while ((matches = regex.exec(JSON.stringify(sidebar))) !== null) {
    result.push(`${path}/${matches[1]}.md`)
  }
  return result
}

// 获取文件提交时间
export function getGitTimestamp(file: string) {
  return new Promise<[number, number]>((resolve, reject) => {
    // 开启子进程执行git log命令
    const child = spawn('git', ['--no-pager', 'log', '--pretty="%ci"', file])
    let output: string[] = []
    child.stdout.on('data', (d) => {
      output.push(...String(d).trim().split('\n'))
    })
    child.on('close', () => {
      resolve([+new Date(output[0]), +new Date(output[output.length - 1])])
    })
    child.on('error', reject)
  })
}
```
:::

2. 在`.vitepress/config.ts`中加入以下代码：

```ts
import { DefaultTheme, UserConfig } from 'vitepress'
import sidebar from './sidebar'
import readPages, { getGitTimestamp } from './readPages'

async function config() {
  return {
    ...
    themeConfig: {
      // 添加页面信息，可以传入对象参数：
      // ignorePath?: string[] 忽略读取的路径
      // sidebar?: Sidebar sidebar对象
      // path?: string 文档主目录，默认/docs
      pages: await readPages({ sidebar }),
      // 读取package.json第一次提交时间作为项目创建时间
      firstCommit: (await getGitTimestamp('package.json'))[1],
      ...
    },
    ...
  } as UserConfig<DefaultTheme.Config>
}

export default config()
```

## 自定义首页

创建`components/Home.vue`文件，并修改`index.md`:

```md
---
layout: home
---

<script setup>
  import Home from './components/Home.vue'
</script>

<Home />
```

> 单独抽离Vue文件主要是为了使用代码提示等编辑器功能

本站直接复用了`VitePress`默认主题中的组件来实现功能，你完全可以自己设计首页组件

![首页](/images/工具系列/VitePress搭建-扩展首页内容-1.png)

## 实现文章列表

从`pages`数据中很轻易能够生成文章列表，但有几个值得注意的点：

1. 文章`md`文件内的标题和`nav`中的标题不一定一致，在文章列表中更适合提取`md`文件内定义的标题
2. 可能存在标题是`FrontMatter`变量的情况，这时候需要提取变量名后替换实际标题
3. 如果直接用文章内容作为简介，需要对`md`标签做处理

```vue
<script setup>
...
  const features = ref<Feature[]>(
    pages.map((item) => {
      // 正则提取文章标题（第一个一级标题）
      let regTitle = item.content.match(/[\s\S]*?# (\S+?)\s+[\s\S]*/)?.[1]
      // 判断标题是否是frontmatter变量
      const matterTitle = regTitle?.match(/\{\{\$frontmatter\.(\S+)\}\}/)?.[1]
      if (matterTitle) {
        // 是变量的话用实际值替换
        regTitle = item.frontMatter[matterTitle]
      }
      return {
        title: regTitle || item.title,
        // 简单删除标题标签后作为简介，可以自定义更精细化的处理
        details: item.content.replace(/#* [\S]+?\n/g, ''),
        link: item.path,
        linkText: dayjs(item.frontMatter.date[0]).format('YYYY-MM-DD'),
      }
    })
  )
</script>

<style scoped>
/* 定义简介内容2行省略 */
:deep(.details) {
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}
</style>
```

## 实现随机跳转

定义获取**0 至 总篇数**的随机数便可以实现随机跳转，因为文档跳转都是在页面内跳转，也无需处理重新生成随机数的问题（跳转返回首页后随机函数会重新执行）

```js
const actions = ref([
  {
    text: '随便逛逛',
    link: randomPage(),
  },
])

function randomPage(): string {
  const length = pages.length - 1
  return pages[Math.floor(Math.random() * length)].path
}
```

## 显示项目运行时长与总篇数

使用了[Dayjs](https://dayjs.gitee.io/zh-CN/)格式化时间，再通过`setInterval`每秒更新即可

```ts
// 传入Hero组件的tagline值
const tagline = ref()
// 更新时间函数
const update = () => {
  const diff = dayjs().diff(dayjs(firstCommit))
  const diffDays = dayjs.duration(diff).days()
  const diffHours = dayjs.duration(diff).hours()
  const diffMinutes = dayjs.duration(diff).minutes()
  const diffSeconds = dayjs.duration(diff).seconds()
  tagline.value = `过去的${diffDays || ''}天${diffHours || ''}时${diffMinutes < 10 ? `0${diffMinutes}` : diffMinutes}分${diffSeconds < 10 ? `0${diffSeconds}` : diffSeconds}秒中，本站累计更新${
    pages.length
  }篇文章`
  // 返回自身，用于setInterval立即执行一次
  return update
}
// 需要立即执行一次update，如果直接传update而不立即执行则首次显示会延迟1秒
const timer = setInterval(update(), 1000)
// 页面协助时取消定时器，避免内存泄漏
onUnmounted(clearInterval.bind(null, timer))
```

## Home完整代码

```vue
<template>
  <VPHero name="XaviDocs" text="个人技术文档" :tagline="tagline" :image="image" :actions="actions" />
  <VPFeatures :features="features" />
</template>

<script setup lang="ts">
import dayjs from 'dayjs'
import relativeTime from 'dayjs/plugin/relativeTime'
import duration from 'dayjs/plugin/duration'
import 'dayjs/locale/zh-cn'
import { onUnmounted, ref } from 'vue'
import { useData } from 'vitepress'
import VPHero from 'vitepress/dist/client/theme-default/components/VPHero.vue'
import VPFeatures, { type Feature } from 'vitepress/dist/client/theme-default/components/VPFeatures.vue'
import { type Pages } from '../.vitepress/readPages'

dayjs.locale('zh-cn')
dayjs.extend(duration)
dayjs.extend(relativeTime)

const data = useData()
const pages: Pages[] = data.theme.value.pages
const firstCommit: number = data.theme.value.firstCommit

const tagline = ref()
const update = () => {
  const diff = dayjs().diff(dayjs(firstCommit))
  const diffDays = dayjs.duration(diff).days()
  const diffHours = dayjs.duration(diff).hours()
  const diffMinutes = dayjs.duration(diff).minutes()
  const diffSeconds = dayjs.duration(diff).seconds()
  tagline.value = `过去的${diffDays || ''}天${diffHours || ''}时${diffMinutes < 10 ? `0${diffMinutes}` : diffMinutes}分${diffSeconds < 10 ? `0${diffSeconds}` : diffSeconds}秒中，本站累计更新${
    pages.length
  }篇文章`
  return update
}
const timer = setInterval(update(), 1000)
onUnmounted(clearInterval.bind(null, timer))

const image = { light: 'svg/pic1.svg', dark: 'svg/pic2.svg' }
const actions = ref([
  {
    text: '随便逛逛',
    link: randomPage(),
  },
])

const features = ref<Feature[]>(
  pages.map((item) => {
    let regTitle = item.content.match(/[\s\S]*?# (\S+?)\s+[\s\S]*/)?.[1]
    const matterTitle = regTitle?.match(/\{\{\$frontmatter\.(\S+)\}\}/)?.[1]
    if (matterTitle) {
      regTitle = item.frontMatter[matterTitle]
    }
    return {
      title: regTitle || item.title,
      details: item.content.replace(/#* [\S]+?\s/g, ''),
      link: item.path,
      linkText: dayjs(item.frontMatter.date[0]).format('YYYY-MM-DD'),
    }
  })
)

function randomPage(): string {
  const length = pages.length - 1
  return pages[Math.floor(Math.random() * length)].path
}
</script>

<style scoped>
:deep(.details) {
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}
</style>
```
